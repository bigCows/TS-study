# HTTP请求

## 请求报文组成

    请求行 请求头  请求空行(告诉服务器，请求头到此结束) 请求体
    
    请求行由请求方法、请求路径、请求协议(HTTP1.0、HTTP1.1、HTTP2.0)组成

    回车符CRLF 换行符LF

## 响应报文组成

    状态行(协议版本、状态码、描述)  消息报头(响应头)  响应空行(告诉浏览器，响应头到此结束)  响应正文(响应体)

	在http协议中，GET . OPTION . 都是支持缓存的。浏览器支持两种标准缓存策略，强缓存，协商缓存

### 强缓存
	浏览器的缓存规范允许服务器返回资源的时候带有Cache-Control响应头
``` javascript
Cache-Control常用响应头
Cache-Control:max-age=<seconds>
```
	使用缓存需要满足的三个条件
```javascript
请求的动作是GET
两次请求url完全相同(host,pathname,query)
请求头不带有Cache-Control:no-cache 和 Pragma:no-cache
```
$$
浏览器标准，通过地址栏访问，以及强制刷新网页的时候。http请求头回自动带上Cache-Control:no-cache和Pragma:no-cache只要有这两个请求头之一，浏览器就会忽略响应头中的Cache-Control字段,所以/路径返回的index.html不会被缓存，因为他是在地址栏访问的
$$

注意，这并不是说网页不会被缓存，而是 _资源被访问的方式_ （比如直接通过地址栏）会导致服务器返回给浏览器响应头中的`Cache-Control`信息被忽略。如果这个网页是通过 iframe 加载的，那么这个网页就可能被浏览器缓存。

通常，在开发 Web 应用时，服务器都会带有强缓存策略。一般的网站，静态资源的内容还会被放到 CDN（内容分发网络）中，以提升访问速度。CDN 网关会给资源文件添加很长时间的强缓存策略甚至是永久的缓存。所以我们更新 Web 应用时，如果有部分静态资源文件，比如图片、JS、CSS 的内容改变，但是文件名没有改变，应用更新后，会发现 html 内容更新了，而页面中的图片、脚本还是旧的，但是用浏览器地址栏访问这些文件，看到的又是新的。产生这种“奇怪”的现象，就是因为**我们浏览器的强缓存策略，在不是通过地址栏访问资源的情况下，需要强制刷新才能更新资源**。

我们无法强迫用户去强制刷新浏览器，所以一般来说，Web 应用更新时应该主动变更修改过的资源文件的 URL。要改变 URL，我们可以修改文件名，或者在 URL 上增加随着发布版本改变的 query 字段，以避免强缓存被触发。这个步骤在现在的 Web 开发中，一般交给工程化脚本去完成。

### 协商缓存
	强缓存对地址栏访问无效，但浏览器提供了另一种缓存策略 可以缓存地址栏访问的文件，这种策略叫协商缓存  
                                                                                                  
    协商缓存，以HTTP内容协商的方式实现缓存。协商缓存规定，浏览器发起HTTP请求的时候，服务器可以返回<span style="color:green">Last-Modified</span>响应头，这个响应头的值是一个时间戳，如果服务器这么做了，浏览器会缓存这个资源。并在今后请求该资源的时候，会带有<span style="color:green">if-modified-since</span>请求头，他的值是上一次<span style="color:green">Last-Modified</span>响应头中的时间戳

    服务器收到带有<span style="color:green">if-modified-since</span>请求头的请求，根据请求头中的时间戳，对文件进行判断，如果文件内容在该时间戳之后到当前时间里没有被修改，服务器返回304响应，该响应表示只有HEAD没有BODY。浏览器收到304响应，就会以缓存内容作为BODY

